<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_dark_eclair</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Initialize Variables
depth = -99999999999999;
grav = 0.75;
hsp = 0;
vsp = 0;
h_acc = 2;
jumpspeed = 13.5;
movespeed = 6;
slowspeed = 3;
orientation = 1;
walljump_stun = 0;
aim_angle = 0;
dash_angle = 0;
dash_speed = 45;
dash_radius = 50;
dash_duration = 0;
dash_slash_angle = 0;
radius = 48;
//crosshair = instance_create(x + sign(orientation) * radius * cos(aim_angle), y + radius * sin(aim_angle), obj_crosshair);
//crosshair.visible = false;
aim_speed_factor = 0.05;
save_aim_state_duration = 0;
bullet_spread = degtorad(5);
meeting_incline = false;
max_hp = 100;
max_energy = 100;
energy = max_energy;
incline = false;
slash_radius = 50;
slash_angle = 0;
air_dash = true;
shake_duration = 0;
touching_ground = false;
ducking = false;
instance_create(x, y, obj_lightsaber);
instance_create(x, y, obj_char_legs);
instance_create(x, y, obj_char_torso);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.player_hp = max_hp;
if(global.deaths &gt; 2){
    room_goto(Room_Skip);
    instance_destroy();
}else{
    room_goto(global.respawn_room);
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Get the player's input
if(!global.respawn){
script_keycheck();


//React to move inputs
if(!key_down){
    move = key_left + key_right;
}else{
    move = 0;
}
if(move != 0 &amp;&amp; walljump_stun &lt;= 0 &amp;&amp; dash_duration &lt;= 0){
    if(abs(hsp) &lt; movespeed){
        hsp += move * h_acc;
    }else{
        hsp = move * movespeed;
    }
    orientation = move;
}else{
    hsp -= sign(hsp) * slowspeed;
    if(abs(hsp) &lt; slowspeed){
        hsp = 0;
    }
}
 
//Interactions with ground and jumping
if (vsp &lt; 20) vsp += grav;
 
if (place_meeting(x,y+1,obj_solid))
{
    touching_ground = true;
    if(!key_aim &amp;&amp; dash_duration &lt;= 0){
        if(!key_down){
            vsp = key_jump * -jumpspeed;
        }
        slowspeed = 3;
    }
    air_dash = true;
}else{
    slowspeed = 2;
    touching_ground = false;
    //walljump
    if(place_meeting(x+1, y, obj_solid)){
        if(key_jump != 0){
            vsp = key_jump * -jumpspeed;
            hsp = -movespeed;
            walljump_stun = 5;
        }
    }else if(place_meeting(x-1, y, obj_solid)){
        if(key_jump != 0){
            vsp = key_jump * -jumpspeed;
            hsp = movespeed;
            walljump_stun = 5;
        }
    }
}

if(key_up_released &amp;&amp; vsp &lt; 0 &amp;&amp; walljump_stun &lt;= 0){
    vsp = 0;
}

if(dash_duration &gt; 0){
    vsp = 0;
}
 
//Horizontal Collision
if (place_meeting(x+hsp,y,obj_solid))
{
    air_dash = true;
    while(!place_meeting(x+sign(hsp),y,obj_solid))
    {
        x += sign(hsp);
    }
    hsp = 0;
}
x += hsp;

//Vertical Collision
if (place_meeting(x,y+vsp,obj_solid) &amp;&amp; !incline)
{
    while(!place_meeting(x,y+sign(vsp),obj_solid))
    {
        y += sign(vsp);
    }
    vsp = 0;
}
y += vsp;

//reset aim angle
if(key_aim_pressed &amp;&amp; save_aim_state_duration &lt;= 0){
    aim_angle = 0;
}

//aim action
/*if(key_aim){
    aim_angle += aim_speed_factor * (key_up - key_down);
    if(abs(aim_angle) &gt; pi/2){
        aim_angle = sign(aim_angle) * pi/2;
    }
    
    //create crosshair
    crosshair.visible = true;
    crosshair.x = x + sign(orientation) * radius * cos(aim_angle);
    crosshair.y = y - radius * sin(aim_angle);
}else{
    crosshair.visible = false;
}*/

//shoot action
/*if(key_shoot){
    var laser = instance_create(x, y, obj_laser);
    laser.proj_direction = orientation;
    laser.angle = aim_angle;
    save_aim_state_duration = 15;
}*/

//shoot with mouse released m1
/*if(mouse_shoot_released){
    var laser = instance_create(x, y, obj_laser);
    if(sign(mouse_x - x) != 0){
        laser.proj_direction = sign(mouse_x - x);
    }else{
        laser.proj_direction = 1;
    }
    if(mouse_x - x != 0){
        exact_angle = arctan((y - mouse_y) / abs(mouse_x - x));
        laser.angle = random_range(exact_angle - bullet_spread/2, exact_angle + bullet_spread/2);
    }else{
        if(y - mouse_y &lt; 0){
            laser.angle = random_range(-pi/2 - bullet_spread/2, -pi/2 + bullet_spread/2);
        }else{
            laser.angle = random_range(pi/2 - bullet_spread/2, pi/2 + bullet_spread/2);
        }
    }
}*/

//spray with m2
if(mouse_spray){
    var laser = instance_create(x, y, obj_laser);
    if(sign(mouse_x - x) != 0){
        laser.proj_direction = sign(mouse_x - x);
    }else{
        laser.proj_direction = 1;
    }
    if(mouse_x - x != 0){
        exact_angle = arctan((y - mouse_y) / abs(mouse_x - x));
        laser.angle = random_range(exact_angle - bullet_spread/2, exact_angle + bullet_spread/2);
    }else{
        if(y - mouse_y &lt; 0){
            laser.angle = random_range(-pi/2 - bullet_spread/2, -pi/2 + bullet_spread/2);
        }else{
            laser.angle = random_range(pi/2 - bullet_spread/2, pi/2 + bullet_spread/2);
        }
    }
}

//dash
if(key_dash &amp;&amp; energy &gt;= 33 &amp;&amp; air_dash){
    if(sign(mouse_x - x) != 0){
        orientation = sign(mouse_x - x);
    }else{
        orientation = 1;
    }
    if(mouse_x - x != 0){
        dash_angle = 0;// = arctan((y - mouse_y) / abs(mouse_x - x));
    }else{
        if(y - mouse_y &lt; 0){
            dash_angle = -pi/2;
        }else{
            dash_angle = pi/2;
        }
    }
    hsp = orientation * dash_speed * cos(dash_angle);
    vsp = -dash_speed * sin(dash_angle);
    dash_duration = 15;
    dash_slash_angle = point_direction(x, y, mouse_x, mouse_y);
    air_dash = false;
    energy -= 33;
    audio_play_sound(dash_sound, 10, false);
}

//dashing
if(dash_duration &gt; 0){
//    slash = instance_create(x + orientation * dash_radius * cos(dash_angle), y - dash_radius * sin(dash_angle), obj_slash);
//    slash.image_angle = dash_slash_angle;
    if(obj_player.orientation == -1){
        slash_angle = degtorad(point_direction(x, y, mouse_x, mouse_y));
        if(slash_angle &lt; pi/2 || slash_angle &gt; 3*pi/2){slash_angle = pi}
        slash = instance_create(x - orientation * slash_radius * cos(slash_angle), y - slash_radius * sin(slash_angle), obj_slash);
        slash.image_angle = radtodeg(slash_angle);
    }else{
        slash_angle = degtorad(point_direction(x, y, mouse_x, mouse_y));
        if(slash_angle &gt; pi/2 &amp;&amp; slash_angle &lt; 3*pi/2){slash_angle = 0}
        slash = instance_create(x + orientation * slash_radius * cos(slash_angle), obj_player.y - slash_radius * sin(slash_angle), obj_slash);
        slash.image_angle = radtodeg(slash_angle);
    }
    afterimage = instance_create(x, y, obj_player_afterimage);
    afterimage.image_xscale = -orientation;
}

//duck
if(key_down_pressed &amp;&amp; sprite_index != spr_player_duck &amp;&amp; touching_ground){
    y += 32;
    sprite_index = spr_player_duck;
    ducking = true;
}
if(key_down_released &amp;&amp; !place_meeting(x, y-32, obj_solid) &amp;&amp; ducking){
    y -= 32;
    sprite_index = spr_dark_eclair;
    ducking = false;
}

//variable updates
script_var_update();

//check collisions with enemies
enemy = instance_place(x, y, obj_enemy);
if(enemy != noone &amp;&amp; dash_duration &lt;= 0 &amp;&amp; global.hit_duration &lt;= 0){
    global.player_hp -= enemy.damage;
    global.hit_duration = 45;
    audio_play_sound(chomp, 10, false);
}

if(global.player_hp &lt;= 0 &amp;&amp; !global.respawn){
    global.respawn = true;
    script_spawn_wreckage(x, y, 64);
    if(alarm[0] == -1){alarm[0] = 180}
}

//moves the camera and background in response to movement
script_camera_mov();

//orients the player towards the mouse
script_orient();

if(place_meeting(x, y, obj_room_change)){
    room_goto_next();
    instance_destroy();
}

if(shake_duration &gt; 0){
    script_screen_shake();
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draws everything and sets color to black
if(ducking &amp;&amp; !global.respawn){
    draw_self();
}
draw_set_colour(c_black);

//creates crosshair with m1 aim
//if(mouse_spray){
//    draw_circle(mouse_x, mouse_y, max(5, tan(bullet_spread) * distance_to_point(mouse_x, mouse_y)), true);
//}

if(!global.respawn){
    draw_healthbar(x-25, y-51, x+25, y-45, 100*(global.player_hp/max_hp), c_black, c_red, c_red, 0, true, true);
    draw_healthbar(x-25, y-45, x+25, y-42, 100*(energy/max_energy), c_black, c_blue, c_blue, 0, true, true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!global.mute){
    audio_master_gain(0);
    sound_global_volume(0);
    global.mute = true;
}else{
    audio_master_gain(1);
    sound_global_volume(1);
    global.mute = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
